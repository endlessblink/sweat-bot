#!/usr/bin/env python3
"""
Docker Port Management for SweatBot
Finds available ports and generates Docker environment configuration
"""

import socket
import json
import sys
import os
from pathlib import Path
from typing import Optional, Dict

def is_port_available(port: int) -> bool:
    """Check if a port is available for binding"""
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.bind(('', port))
            return True
    except OSError:
        return False

def find_available_port(start_port: int, end_port: int, preferred: Optional[int] = None) -> Optional[int]:
    """Find an available port in the given range"""
    # Try preferred port first if specified
    if preferred and start_port <= preferred <= end_port:
        if is_port_available(preferred):
            return preferred
    
    # Try each port in the range
    for port in range(start_port, end_port + 1):
        if is_port_available(port):
            return port
    
    return None

def generate_docker_env(backend_port: int, frontend_port: int, postgres_port: int = 5432, redis_port: int = 6379) -> str:
    """Generate Docker environment file content"""
    return f"""# SweatBot Docker Configuration
# Auto-generated by docker_ports.py

# Service Ports (Host:Container mapping)
BACKEND_PORT={backend_port}
FRONTEND_PORT={frontend_port}
POSTGRES_PORT={postgres_port}
REDIS_PORT={redis_port}

# Internal URLs (for container-to-container communication)
DATABASE_URL=postgresql://fitness_user:secure_password@postgres:5432/hebrew_fitness
REDIS_URL=redis://:sweatbot_redis_pass@redis:6379/0

# External URLs (for browser access)
NEXT_PUBLIC_API_URL=http://localhost:{backend_port}
NEXT_PUBLIC_WS_URL=ws://localhost:{backend_port}

# Application Settings
SECRET_KEY=your-super-secret-key-change-in-production
DEBUG=true
LOG_LEVEL=INFO

# AI Models
WHISPER_MODEL=ivrit-ai/whisper-large-v3
MODEL_PATH=/app/models

# CORS Settings
CORS_ORIGINS=http://localhost:{frontend_port},http://localhost:{backend_port}
"""

def main():
    """Main function to find ports and generate Docker configuration"""
    print("üîç Finding available ports for Docker services...")
    
    # Find available ports
    backend_port = find_available_port(8000, 8010, 8000)
    if not backend_port:
        print("‚ùå No available backend ports (8000-8010)")
        sys.exit(1)
    
    frontend_port = find_available_port(3000, 3010, 3000)
    if not frontend_port:
        print("‚ùå No available frontend ports (3000-3010)")
        sys.exit(1)
    
    postgres_port = find_available_port(5432, 5442, 5432)
    if not postgres_port:
        print("‚ùå No available PostgreSQL ports (5432-5442)")
        sys.exit(1)
    
    redis_port = find_available_port(6379, 6389, 6379)
    if not redis_port:
        print("‚ùå No available Redis ports (6379-6389)")
        sys.exit(1)
    
    print(f"‚úÖ Found available ports:")
    print(f"   Backend:    {backend_port}")
    print(f"   Frontend:   {frontend_port}")
    print(f"   PostgreSQL: {postgres_port}")
    print(f"   Redis:      {redis_port}")
    
    # Generate .env.docker file
    env_content = generate_docker_env(backend_port, frontend_port, postgres_port, redis_port)
    env_file = Path(".env.docker")
    
    with open(env_file, "w") as f:
        f.write(env_content)
    
    print(f"‚úÖ Docker environment saved to {env_file}")
    
    # Also save as JSON for scripts to read
    config = {
        "backend": backend_port,
        "frontend": frontend_port,
        "postgres": postgres_port,
        "redis": redis_port,
        "urls": {
            "backend": f"http://localhost:{backend_port}",
            "frontend": f"http://localhost:{frontend_port}",
            "api_docs": f"http://localhost:{backend_port}/docs"
        }
    }
    
    config_file = Path(".docker-ports.json")
    with open(config_file, "w") as f:
        json.dump(config, f, indent=2)
    
    print(f"‚úÖ Port configuration saved to {config_file}")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())